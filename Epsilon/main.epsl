/*
LetterResponse enum values:
0 = GRAY
1 = ORANGE
2 = GREEN
*/

Str#find_best_word<[Str]:words> {
    [W]:frequencies = [[W] []].blank_from_type[26];
    W:i = 0;
    while (i < [words].length) {
        W:j = 0;
        Str:word = words[i];
        while (j < [word].length) {
            frequencies[word[j++] - 'a']++;
        };
        i++;
    };
    W:bestScore = 0;
    Str?:best = null;
    i = 0;
    while (i < [words].length) {
        Str:word2 = words[i];
        Str:chars = [word2].clone;
        [chars].unique;
        W:score = 0;
        W:j = 0;
        while (j < [chars].length) {
            score += frequencies[chars[j++]-'a'];
        };
        if (score > bestScore) {
            bestScore = score;
            best = word2;
        };
        i++;
    };
    return [best].unwrap;
}

[W]#get_wordle_response<Str:guess><Str:target> {
    [W]:response = [W] [];
    W:i = 0;
    while (i < [guess].length) {
        Byte:gchar = guess[i];
        if (gchar == target[i]) {
            [response].append[2];
        } elif ([target].index_of[gchar] != -1) {
            [response].append[1];
        } else {
            [response].append[0];
        };
        i++;
    };
    return response;
}

[Str]#filter_words_given_response<[Str]:words><[W]:response><Str:guess> {
    [Str]:result = [Str] [];
    W:i = 0;
    while (i < [words].length) {
        Str:word = words[i];
        i++;
        W:j = 0;
        Bool:valid = true;
        while (j < [word].length) {
            Byte:gchar = guess[j];
            Byte:wchar = word[j];
            W:lresponse = response[j];
            uninit Bool:validc;
            if (lresponse == 2) {
                uninit validc = wchar == gchar;
            } elif (lresponse == 1) {
                uninit validc = wchar != gchar && ([word].index_of[gchar] != -1);
            } else {
                uninit validc = [word].index_of[gchar] == -1;
            };
            j++;
            if (!validc) {
                valid = false;
                break;
            };
        };
        if (valid) {
            [result].append[word];
        };
    };
    return result;
}

Bool#do_wordle<[Str]:words><Str:target> {
    W:i = 0;
    while (i < 6) {
        Str:guess = find_best_word[words];
        if ([guess] equals [target]) {
            return true;
        };
        [W]:response = get_wordle_response[guess][target];
        words = filter_words_given_response[words][response][guess];
        i++;
    };
    return false;
}

Z#main {
    File:file = open_file["words.txt"][FILE_READ_MODE];
    if (![file].is_open) {
        abort["Failed to open file"];
    };
    [Str]?:nullableWords = [file].read_lines;
    if ([nullableWords].is_null) {
        abort["Failed to read file content"];
    };
    [Str]:words = [nullableWords].unwrap;

    W:succeeded = 0;
    W:failed = 0;

    W:i = 0;
    while (i < [words].length) {
        Bool:success = do_wordle[words][words[i]];
        if (success) {
            succeeded++;
        } else {
            failed++;
        };
        i++;
    };

    println[["Succeeded: "] + [[succeeded].stringify]];
    println[["Failed: "] + [[failed].stringify]];
    
    return 0;
}
